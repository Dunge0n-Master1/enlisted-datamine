sequencer{
  name:t="sub.chooseMaxStance"

  orderedSelector{

    chooseMinMaxStancesForCoverAttack{
    }

    sequencer{

      chooseMaxStance{
      }

      orderedSelector{

        sequencer{

          isAgentPlayerBot{
          }

          setIntVar{
            to:t="minStance"
            value:i=1
          }
        }

        setIntVar{
          to:t="minStance"
          value:i=0
        }
      }
    }
  }
}

sequencer{
  name:t="sub.deactivateWeapMod"

  deactivateWeapMod{
  }
}

sequencer{
  name:t="sub.checkDowned"

  isDowned{
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.checkBurning"

  isBurning{
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.findCover"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getRegroupDistance{
    minDist:r=8.0
    distParam:t="regroupDistance"
  }

  findCover{
    centerParam:t="regroupPosition"
    centerRadiusParam:t="regroupDistance"
    radius:r=8.0
    dangerRadius:r=0.0
    dangerMinNoiseLevel:r=0.5
    coverPosParam:t="coverPos"
  }

  calcDistance{
    startPosParam:t="coverPos"
    endPosParam:t="regroupPosition"
    distanceParam:t="coverRegroupDistance"
  }

  checkDistance{
    posParam:t="coverPos"
    radiusParam:t="coverRegroupDistance"
    yRadius:r=2.5
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.findCoverAroundLeader"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  ifThenElse{

    and{

      isSquadLeaderMoving{
      }

      isAgressiveBehaviour{
      }
    }

    setRealVar{
      to:t="possibleAngle"
      value:r=180.0
    }

    setRealVar{
      to:t="possibleAngle"
      value:r=80.0
    }
  }

  orderedSelector{

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=3.0
      possibleAngleParam:t="possibleAngle"
      coverPosParam:t="coverPos"
      minDist:r=2.0
      maxOccupied:i=3
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=4.0
      possibleAngleParam:t="possibleAngle"
      coverPosParam:t="coverPos"
      minDist:r=3.0
      maxOccupied:i=2
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=3.0
      possibleAngle:r=180.0
      coverPosParam:t="coverPos"
      minDist:r=1.0
    }
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.findCoverAroundLeaderAway"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getOrderPosition{
    posParam:t="regroupPosition"
    orderPosParam:t="spreadPos"
    traceVisible:b=yes
  }

  ifThenElse{

    and{

      isSquadLeaderMoving{
      }

      isAgressiveBehaviour{
      }
    }

    setRealVar{
      to:t="possibleAngle"
      value:r=180.0
    }

    setRealVar{
      to:t="possibleAngle"
      value:r=100.0
    }
  }

  orderedSelector{

    findCoverAroundPoint{
      centerParam:t="spreadPos"
      radius:r=5.0
      possibleAngleParam:t="possibleAngle"
      coverPosParam:t="coverPos"
      minDist:r=0.0
      maxOccupied:i=1
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="spreadPos"
      radius:r=3.0
      possibleAngleParam:t="possibleAngle"
      coverPosParam:t="coverPos"
      minDist:r=0.0
      maxOccupied:i=2
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=5.0
      possibleAngle:r=180.0
      coverPosParam:t="coverPos"
      minDist:r=3.0
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=3.0
      possibleAngle:r=180.0
      coverPosParam:t="coverPos"
      minDist:r=2.0
    }
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.findCoverAroundPoint"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getOrderPosition{
    posParam:t="regroupPosition"
    orderPosParam:t="spreadPos"
  }

  orderedSelector{

    findCoverAroundPoint{
      centerParam:t="spreadPos"
      radius:r=7.0
      coverPosParam:t="coverPos"
      minDist:r=0.0
      maxOccupied:i=1
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="spreadPos"
      radius:r=6.0
      coverPosParam:t="coverPos"
      minDist:r=0.0
      maxOccupied:i=2
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=5.0
      possibleAngle:r=180.0
      coverPosParam:t="coverPos"
      minDist:r=2.0
      traceVisible:b=yes
    }

    findCoverAroundPoint{
      centerParam:t="regroupPosition"
      radius:r=3.0
      possibleAngle:r=180.0
      coverPosParam:t="coverPos"
      minDist:r=2.0
    }
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.checkCover"

  checkCover{
    dangerRadius:r=0.0
    dangerMinNoiseLevel:r=0.5
  }

  getCoverPosition{
    coverPosParam:t="coverPos"
  }

  checkAllowedPosition{
    posParam:t="coverPos"
  }

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getRegroupDistance{
    minDist:r=8.0
    distParam:t="regroupDistance"
  }

  checkDistance{
    posParam:t="regroupPosition"
    otherPosParam:t="coverPos"
    radiusParam:t="regroupDistance"
    yRadius:r=2.5
  }

  checkDistance{
    posParam:t="coverPos"
    radiusParam:t="coverRegroupDistance"
    yRadius:r=2.5
  }

  calcDistance{
    startPosParam:t="coverPos"
    endPosParam:t="regroupPosition"
    distanceParam:t="coverRegroupDistance"
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.checkCoverAroundPoint"

  getCoverPosition{
    coverPosParam:t="coverPos"
  }

  checkAllowedPosition{
    posParam:t="coverPos"
  }

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getRegroupDistance{
    minDist:r=8.0
    distParam:t="regroupDistance"
  }

  checkDistance{
    posParam:t="regroupPosition"
    otherPosParam:t="coverPos"
    radiusParam:t="regroupDistance"
    yRadius:r=2.5
  }

  copyPoint3Var{
    from:t="coverPos"
    to:t="wishPosition"
  }
}

sequencer{
  name:t="sub.regroupCheck"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  not{

    orderedSelector{

      sequencer{

        findDanger{
          paramName:t="testEnemy"
          radiusParamName:t="enemyRadius"
          minDanger:r=-1.0
          tag:t="human"
        }

        checkDistance{
          posParam:t="regroupPosition"
          otherPosParam:t="storedRegroupPosition"
          radius:r=2.5
          yRadius:r=2.5
        }
      }

      checkDistance{
        posParam:t="regroupPosition"
        otherPosParam:t="storedRegroupPosition"
        radius:r=8.0
        yRadius:r=2.5
      }
    }
  }

  copyPoint3Var{
    from:t="regroupPosition"
    to:t="storedRegroupPosition"
  }

  getOrderPosition{
    posParam:t="regroupPosition"
    orderPosParam:t="wishPosition"
  }
}

sequencer{
  name:t="sub.changeStanceWhenInTheSquadLeaderAim"

  findDanger{
    paramName:t="testEnemy"
    radiusParamName:t="enemyRadius"
    minDanger:r=-1.0
    tag:t="human"
  }

  isInSquadLeaderAim{
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.moveTraceableDangerCheck"

  periodicTimer{
    timeParam:t="onTraceableDangerTimer"
    timePeriod:p2=2.0, 4.0
  }

  findDanger{
    paramName:t="shootEnemy"
    radiusParamName:t="enemyRadius"
    minDanger:r=0.1
    tag:t="human"
  }

  increaseDangerLevel{
    paramName:t="dangerLevel"
    targetParam:t="shootEnemy"
  }

  decideOnAttackTarget{
    targetParam:t="shootEnemy"
    targetSeeTimeParam:t="shootEnemyTime"
    stillTimeOutParam:t="attackStillTime"
    turnAngleOutParam:t="attackTurnAngle"
    focusTimeOutParam:t="attackFocusTime"
    checkOnly:b=yes
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.moveFindDangerCheck"

  periodicTimer{
    timeParam:t="onFollowPosFindDangerTimer"
    timePeriod:p2=2.0, 4.0
  }

  findDanger{
    paramName:t="shootEnemy"
    radiusParamName:t="enemyRadius"
    minDanger:r=0.1
    tag:t="human"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.findDangerGrenade"

  findDangerGrenade{
    grenTargetParam:t="dangerLookAt"
    radius:r=20.0
    grenExplTime:t="grenExplTime"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.findDangerGrenadeNearby"

  findDangerGrenade{
    grenTargetParam:t="dangerLookAt"
    radius:r=10.0
    grenExplTime:t="grenExplTime"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.grenadeEscape"

  reaction{
    event:t="regularCheck"

    repeat{
      count:i=1

      subTree{
        name:t=""
        treeName:t="sub.chooseMaxStance"
      }

      subTree{
        name:t=""
        treeName:t="sub.deactivateWeapMod"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkDowned"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkBurning"
      }
    }
  }

  findDangerGrenade{
    grenTargetParam:t="dangerLookAt"
    radius:r=20.0
    grenExplTime:t="grenExplTime"
  }

  findSafeFromGrenadePos{
    posParam:t="grenadeSafePos"
    grenTargetParam:t="dangerLookAt"
    radius:r=25.0
  }

  speak{
    phrase:t="grenadeAware"
    timeMinMax:p2=4.0, 10.0
  }

  setCurrentAiAction{
    state:t="hide"
  }

  wait{
    range:p2=0.1, 0.3
    resetable:b=yes
  }

  wait{
    range:p2=0.2, 0.4
    resetable:b=yes
  }

  moveToPos{
    posParam:t="grenadeSafePos"
    sprintTimerRange:p2=10.0, 20.0
    minDistToSprint:r=0.5
    tryClimbing:b=yes
    maxStanceParam:t="maxStance"
    avoidAiObstacles:b=no
  }
}

sequencer{
  name:t="sub.bombEscape"

  reaction{
    event:t="regularCheck"

    repeat{
      count:i=1

      subTree{
        name:t=""
        treeName:t="sub.chooseMaxStance"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkDowned"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkBurning"
      }
    }
  }

  findDangerousBomb{
    dangerPosParam:t="bombDangerousPos"
  }

  findSafeFromBombPos{
    dangerPosParam:t="bombDangerousPos"
    safePosParam:t="currentSafePos"
  }

  setCurrentAiAction{
    state:t="hide"
  }

  wait{
    range:p2=0.1, 0.3
    resetable:b=yes
  }

  wait{
    range:p2=0.8, 1.2
    resetable:b=yes
  }

  moveToPos{
    posParam:t="currentSafePos"
    sprintTimerRange:p2=10.0, 20.0
    minDistToSprint:r=0.5
    tryClimbing:b=yes
    maxStanceParam:t="maxStance"
    avoidAiObstacles:b=no
  }
}

sequencer{
  name:t="sub.rethrowGrenade"

  not{

    isSwimming{
    }
  }

  findDangerGrenade{
    grenTargetParam:t="dangerLookAt"
    radius:r=2.5
    yRadius:r=1.0
    allowUnderWater:b=no
    maxWaterDepth:r=0.1
    grenExplTime:t="grenExplTime"
  }

  setCurrentAiAction{
    state:t="attack"
  }

  parallel{

    throwGrenadeBack{
      grenTargetParam:t="dangerLookAt"
      posParam:t="grenadeThrowPos"
      radius:r=10.0
      minThrowDistance:r=20.0
    }

    sequencer{

      moveToPos{
        posParam:t="grenadeThrowPos"
        sprintTimerRange:p2=10.0, 20.0
        minDistToSprint:r=0.5
        tryClimbing:b=yes
        distThreshold:r=1.0
        avoidAiObstacles:b=no
      }

      wait{
        range:p2=2.0, 2.0
        resetable:b=yes
      }
    }
  }

  changeStance{
    stanceName:t="crawl"
    maxStanceParam:t="maxStance"
  }

  wait{
    range:p2=1.0, 2.0
    resetable:b=yes
  }
}

sequencer{
  name:t="sub.selfHealing"

  isDowned{
  }

  setCurrentAiAction{
    state:t="heal"
  }

  wait{
    range:p2=0.2, 0.5
    resetable:b=yes
  }

  useMedkit{
  }
}

sequencer{
  name:t="sub.findDangerZone"

  isVarsIntEqual{
    lhs:t="dmgZoneEscaping"
    rhs_value:i=0
  }

  periodicTimer{
    timeParam:t="onDmgZoneDetectTimer"
    timePeriod:p2=2.0, 4.0
  }

  periodicTimer{
    timeParam:t="onDmgZoneAlarmTimer"
    timePeriod:p2=5.0, 8.0
  }

  orderedSelector{

    findActiveDamageZone{
      safePosParam:t="dmgZoneEscapePos"
    }

    sequencer{

      isLeader{
      }

      isAgentPlayerBot{
      }

      findActiveDamageZone{
        safePosParam:t="dmgZoneEscapePos"
        findWarning:b=yes
      }

      not{

        isIndoor{
        }
      }
    }
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.selfExtinguish"

  isBurning{
  }

  setCurrentAiAction{
    state:t="heal"
  }

  repeat{
    count:i=1

    sequencer{

      isVarsIntEqual{
        lhs:t="dmgZoneEscaping"
        rhs_value:i=0
      }

      findActiveDamageZone{
        safePosParam:t="dmgZoneEscapePos"
      }

      exitHandler{

        sequencer{

          setIntVar{
            to:t="dmgZoneEscaping"
            value:i=1
          }

          parallel{

            moveToPos{
              posParam:t="dmgZoneEscapePos"
              sprintTimerRange:p2=10.0, 20.0
              minDistToSprint:r=0.5
              tryClimbing:b=no
              distThreshold:r=1.0
              avoidAiObstacles:b=no
            }

            extinguish{
            }
          }
        }

        setIntVar{
          to:t="dmgZoneEscaping"
          value:i=0
        }
      }
    }

    sequencer{

      reaction{
        event:t="regularCheck"

        subTree{
          name:t=""
          treeName:t="sub.findDangerZone"
        }
      }

      extinguish{
      }
    }
  }
}

sequencer{
  name:t="sub.dmgZoneEscape"

  orderedSelector{

    findActiveDamageZone{
      safePosParam:t="dmgZoneEscapePos"
    }

    sequencer{

      isLeader{
      }

      isAgentPlayerBot{
      }

      findActiveDamageZone{
        safePosParam:t="dmgZoneEscapePos"
        findWarning:b=yes
      }

      not{

        isIndoor{
        }
      }

      copyPoint3Var{
        from:t="regroupPosition"
        to:t="storedRegroupPosition"
      }

      copyPoint3Var{
        from:t="dmgZoneEscapePos"
        to:t="regroupPosition"
      }
    }
  }

  periodicTimer{
    timeParam:t="onDmgZoneEscapeTimer"
    timePeriod:p2=3.0, 5.0
  }

  exitHandler{

    sequencer{

      reaction{
        event:t="regularCheck"

        repeat{
          count:i=1

          subTree{
            name:t=""
            treeName:t="sub.swimUpCheck"
          }

          subTree{
            name:t=""
            treeName:t="sub.tryToOpenDoors"
          }
        }
      }

      setIntVar{
        to:t="dmgZoneEscaping"
        value:i=1
      }

      setCurrentAiAction{
        state:t="move"
      }

      wait{
        range:p2=0.2, 0.3
        resetable:b=yes
      }

      parallel{

        moveToPos{
          posParam:t="dmgZoneEscapePos"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=0.5
          tryClimbing:b=yes
          distThreshold:r=1.0
          avoidAiObstacles:b=no
        }

        extinguish{
        }
      }
    }

    setIntVar{
      to:t="dmgZoneEscaping"
      value:i=0
    }
  }
}

sequencer{
  name:t="sub.swimUpCheck"

  isUnderwater{
  }

  hasBreath{
    ratio:r=0.5
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.swimUp"

  reaction{
    event:t="regularCheck"

    findObstaclesAlongsidePath{
    }
  }

  isUnderwater{
  }

  hasBreath{
    ratio:r=0.5
  }

  orderedSelector{

    findSwimUpPos{
      posParam:t="swimUpPos"
      swimUpDirParam:t="swimUpDir"
      radius:r=5.0
      tries:i=1
    }

    findSwimUpPos{
      posParam:t="swimUpPos"
      swimUpDirParam:t="swimUpDir"
      radius:r=5.0
      tries:i=10
    }
  }

  setCurrentAiAction{
    state:t="move"
  }

  parallel{

    moveToPos{
      posParam:t="swimUpPos"
      sprintTimerRange:p2=10.0, 20.0
      minDistToSprint:r=10.0
      distThreshold:r=1.5
      avoidAiObstacles:b=yes
    }

    waitSwimUpPos{
      delay:r=0.1
      maxTime:r=4.0
      swimUpDirParam:t="swimUpDir"
    }
  }

  swimUp{
    swimUpDirParam:t="swimUpDir"
  }
}

sequencer{
  name:t="sub.enemyMelee"

  findDanger{
    paramName:t="meleeEnemy"
    radiusParamName:t="enemyMeleeRadius"
    minDanger:r=0.1
    tag:t="human"
  }

  getTime{
    to:t="enemyNearTime"
  }

  increaseDangerLevel{
    paramName:t="dangerLevel"
    targetParam:t="meleeEnemy"
  }

  setCurrentAiAction{
    state:t="attack"
  }

  moveToTarget{
    targetUnitParam:t="meleeEnemy"
    stopDist:r=0.75
    aimToTarget:b=yes
    maxStanceParam:t="maxStance"
    timeLimit:r=3.0
  }

  meleeAttack{
    targetUnitParam:t="meleeEnemy"
    timeToAttack:r=1.0
    attackDist:r=1.5
  }

  wait{
    range:p2=0.5, 1.0
    resetable:b=yes
  }
}

sequencer{
  name:t="sub.oneShootAttack"

  reaction{
    event:t="regularCheck"

    repeat{
      count:i=1

      subTree{
        name:t=""
        treeName:t="sub.chooseMaxStance"
      }

      subTree{
        name:t=""
        treeName:t="sub.deactivateWeapMod"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkDowned"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkBurning"
      }

      subTree{
        name:t=""
        treeName:t="sub.findDangerGrenade"
      }

      subTree{
        name:t=""
        treeName:t="sub.findDangerZone"
      }

      not{

        isGrenadeSelected{
        }
      }
    }
  }

  reaction{
    event:t="onEnemyPlayerNear"

    orderedSelector{

      not{

        isVarsIntEqual{
          lhs:t="coverAttack"
          rhs_value:i=0
        }
      }

      sequencer{

        findDanger{
          paramName:t="meleeEnemy"
          radiusParamName:t="enemyMeleeRadius"
          minDanger:r=0.5
          tag:t="human"
        }

        recalculateTree{
        }
      }

      sequencer{

        findDanger{
          paramName:t="shootEnemy"
          radiusParamName:t="enemyNearRadius"
          minDanger:r=0.5
          tag:t="human"
        }

        orderedSelector{

          isVarsIntEqual{
            lhs:t="prevShootEnemy"
            rhs:t="shootEnemy"
          }

          isGrenadeSelected{
          }

          recalculateTree{
          }
        }
      }
    }
  }

  orderedSelector{

    not{

      isVarsIntEqual{
        lhs:t="coverAttack"
        rhs_value:i=0
      }
    }

    checkAtTime{
      timeParam:t="fastReactTime"
      range:p2=0.0, 5.0
    }

    decideOnAttackTarget{
      targetParam:t="shootEnemy"
      targetSeeTimeParam:t="shootEnemyTime"
      stillTimeOutParam:t="attackStillTime"
      turnAngleOutParam:t="attackTurnAngle"
      focusTimeOutParam:t="attackFocusTime"
    }

    failed{

      wait{
        range:p2=0.3, 0.6
        resetable:b=yes
      }
    }
  }

  orderedSelector{

    not{

      isVarsIntEqual{
        lhs:t="coverAttack"
        rhs_value:i=0
      }
    }

    checkAtTime{
      timeParam:t="fastReactTime"
      range:p2=0.0, 5.0
    }

    sequencer{

      reaction{
        event:t="regularCheck"

        continue{
        }
      }

      reaction{
        event:t="onEnemyPlayerNear"

        continue{
        }
      }

      reaction{
        event:t="onTraceableDanger"

        continue{
        }
      }

      wait{
        timeParam:t="attackStillTime"
        resetable:b=yes
        aimSpeedCoef:r=0.01
      }

      sequencer{

        reaction{
          event:t="onBulletNearby"

          continue{
          }
        }

        rotateToPoint{
          angleParam:t="attackTurnAngle"
        }

        wait{
          timeParam:t="attackFocusTime"
          resetable:b=yes
        }
      }
    }
  }

  orderedSelector{

    sequencer{

      isGrenadeSelected{
      }

      repeat{
        count:i=1

        sequencer{

          getRandomPointAroundTarget{
            targetUnitParam:t="shootEnemy"
            posParam:t="posNearTarget"
            radiusRange:p2=3.0, 6.0
            awayMinRadius:r=7.0
            minDistanceFromAllies:r=7.0
          }

          rotateToPoint{
            posParam:t="posNearTarget"
          }

          orderedSelector{

            sequencer{

              setIntVar{
                to:t="isInShootState"
                value:i=1
              }

              copyIntVar{
                to:t="prevShootEnemy"
                from:t="shootEnemy"
              }

              copyIntVar{
                to:t="rememberEnemy"
                from:t="shootEnemy"
              }

              throwGrenade{
                targetPosParam:t="posNearTarget"
                targetUnitParam:t="shootEnemy"
                grenadeThrowDelay:r=2.5
              }

              wait{
                range:p2=1.0, 1.5
                resetable:b=yes
              }

              getTime{
                to:t="rememberEnemyTime"
              }

              setPosFromEntity{
                to:t="rememberEnemyPos"
                from:t="shootEnemy"
              }
            }

            resetGrenadeThrowTime{
            }
          }

          chooseBestWeapon{
            targetParam:t="shootEnemy"
          }
        }
      }
    }

    sequencer{

      not{

        isGrenadeSelected{
        }
      }

      repeat{
        count:i=1

        sequencer{

          getRandomPointNearTarget{
            targetUnitParam:t="shootEnemy"
            posParam:t="posNearTarget"
            useGenerationByY:b=no
          }

          rotateToPoint{
            posParam:t="posNearTarget"
          }

          orderedSelector{

            sequencer{

              isMeleeWeaponSelected{
              }

              copyIntVar{
                to:t="prevShootEnemy"
                from:t="shootEnemy"
              }

              getRandomPointAroundTarget{
                targetUnitParam:t="shootEnemy"
                posParam:t="posNearTarget"
                radiusRange:p2=1.0, 6.0
                awayMinRadius:r=0.0
              }

              moveToPos{
                posParam:t="posNearTarget"
                sprintTimerRange:p2=10.0, 20.0
                minDistToSprint:r=0.0
                distThreshold:r=0.5
                avoidAiObstacles:b=no
                timeToStuck:r=1.0
              }

              moveToTarget{
                targetUnitParam:t="shootEnemy"
                stopDist:r=0.75
                aimToTarget:b=yes
                maxStanceParam:t="maxStance"
                timeLimit:r=3.0
              }

              meleeAttack{
                targetUnitParam:t="shootEnemy"
                timeToAttack:r=3.0
                attackDist:r=1.5
              }
            }

            sequencer{

              setIntVar{
                to:t="isInShootState"
                value:i=1
              }

              copyIntVar{
                to:t="prevShootEnemy"
                from:t="shootEnemy"
              }

              orderedSelector{

                shootAtUnit{
                  targetUnitParam:t="shootEnemy"
                  minStanceParam:t="minStance"
                  shootCycles:i=1
                  tryToSaveCurrentStance:b=no
                  minStanceChance:r=1.5
                  shootTime:p2=0.2, 1.0
                  cooldownTime:p2=0.2, 0.9
                  minAimTime:p2=0.1, 0.4
                  maxStanceParam:t="maxStance"
                  alwaysAiming:b=yes
                }

                sequencer{

                  setIntVar{
                    to:t="coverAttack"
                    value:i=0
                  }

                  break{
                  }
                }
              }
            }
          }

          getTime{
            to:t="rememberEnemyTime"
          }

          copyIntVar{
            to:t="rememberEnemy"
            from:t="shootEnemy"
          }

          setPosFromEntity{
            to:t="rememberEnemyPos"
            from:t="shootEnemy"
          }
        }
      }
    }
  }

  subTree{
    treeName:t="sub.tryBeginCoverAttack"
  }

  subTree{
    treeName:t="sub.performCoverAttackMoves"
  }

  increaseDangerLevel{
    paramName:t="dangerLevel"
    targetParam:t="shootEnemy"
  }

  decreaseDangerLevel{
    paramName:t="dangerLevel"
    decreaseCoef:r=0.9
  }

  not{

    isVarsIntEqual{
      lhs:t="coverAttack"
      rhs_value:i=1
    }
  }

  setIntVar{
    to:t="isInShootState"
    value:i=0
  }

  chooseBestWeapon{
    targetParam:t="shootEnemy"
    allowGrenades:b=yes
    switchRadiusCoef:r=0.85
  }

  setCurrentAiAction{
    state:t="attack"
  }
}

sequencer{
  name:t="sub.attackVehicle"

  initPeriodicTimer{
    timeParam:t="onAttackVehicleTimer"
    timePeriod:p2=5.0, 8.0
  }

  reaction{
    event:t="regularCheck"

    repeat{
      count:i=1

      subTree{
        name:t=""
        treeName:t="sub.chooseMaxStance"
      }

      subTree{
        name:t=""
        treeName:t="sub.deactivateWeapMod"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkDowned"
      }

      subTree{
        name:t=""
        treeName:t="sub.checkBurning"
      }

      subTree{
        name:t=""
        treeName:t="sub.findDangerGrenade"
      }

      subTree{
        name:t=""
        treeName:t="sub.findDangerZone"
      }
    }
  }

  reaction{
    event:t="onEnemyPlayerNear"

    sequencer{

      periodicTimer{
        timeParam:t="onAttackVehicleTimer"
        timePeriod:p2=5.0, 8.0
      }

      orderedSelector{

        sequencer{

          findDanger{
            paramName:t="meleeEnemy"
            radiusParamName:t="enemyMeleeRadius"
            minDanger:r=0.5
            tag:t="human"
          }

          recalculateTree{
          }
        }

        sequencer{

          findDanger{
            paramName:t="shootEnemy"
            radiusParamName:t="enemyNearRadius"
            minDanger:r=0.5
            tag:t="human"
          }

          recalculateTree{
          }
        }
      }
    }
  }

  increaseDangerLevel{
    paramName:t="dangerLevel"
    targetParam:t="shootEnemy"
  }

  setIntVar{
    to:t="isInShootState"
    value:i=0
  }

  chooseBestWeapon{
    targetParam:t="shootEnemy"
  }

  setCurrentAiAction{
    state:t="attack"
  }

  isGrenadeSelected{
  }

  getRandomPointAroundTarget{
    targetUnitParam:t="shootEnemy"
    posParam:t="posNearTarget"
    radiusRange:p2=0.0, 2.0
    awayMinRadius:r=7.0
    minDistanceFromAllies:r=7.0
  }

  rotateToPoint{
    posParam:t="posNearTarget"
  }

  orderedSelector{

    sequencer{

      setIntVar{
        to:t="isInShootState"
        value:i=1
      }

      throwGrenade{
        targetPosParam:t="posNearTarget"
        targetUnitParam:t="shootEnemy"
        minThrowDistance:r=5.0
      }

      wait{
        range:p2=0.5, 1.0
        resetable:b=yes
      }
    }

    sequencer{

      resetAntiTankGrenadeThrowLimiter{
      }

      break{
      }
    }
  }
}

sequencer{
  name:t="sub.stayTraceableDangerCheck"

  findDanger{
    paramName:t="shootEnemy"
    radiusParamName:t="enemyRadius"
    minDanger:r=0.1
    tag:t="human"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.stayFindDangerCheck"

  findDanger{
    paramName:t="shootEnemy"
    radiusParamName:t="enemyRadius"
    minDanger:r=0.1
    tag:t="human"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.stayFindCover"

  subTree{
    name:t=""
    refId:t="findCoverRef"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.stayRegroupCheck"

  subTree{
    name:t=""
    treeName:t="sub.regroupCheck"
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.tryCallArtillery"

  isAgentPlayerBot{
  }

  checkAtTime{
    timeParam:t="enemyNearTime"
    range:p2=10.0, 1000000.0
  }

  not{

    isSwimming{
    }
  }

  sequencer{

    reaction{
      event:t="onBulletNearby"

      sequencer{

        recalculateTree{
        }
      }
    }

    reaction{
      event:t="onTraceableDanger"

      continue{
      }
    }

    reaction{
      event:t="onEnemyPlayerNear"

      sequencer{

        findDanger{
          paramName:t="shootEnemy"
          radiusParamName:t="enemyNearRadius"
          minDanger:r=0.1
          tag:t="human"
        }

        recalculateTree{
        }
      }
    }

    reaction{
      event:t="regularCheck"

      repeat{
        count:i=1

        subTree{
          name:t=""
          treeName:t="sub.checkDowned"
        }

        subTree{
          name:t=""
          treeName:t="sub.checkBurning"
        }

        subTree{
          name:t=""
          treeName:t="sub.swimUpCheck"
        }

        subTree{
          name:t=""
          treeName:t="sub.findDangerGrenadeNearby"
        }
      }
    }

    not{

      findDanger{
        paramName:t="shootEnemy"
        radiusParamName:t="enemyNearRadius"
        minDanger:r=0.5
        tag:t="human"
      }
    }

    tryCallArtillery{
      initRange:p2=30.0, 90.0
      repeatRange:p2=240.0, 360.0
    }

    wait{
      range:p2=0.5, 1.5
      resetable:b=yes
    }
  }
}

sequencer{
  name:t="sub.checkBuildAndPlace"

  checkAtTime{
    timeParam:t="enemyNearTime"
    range:p2=5.0, 1000000.0
  }

  not{

    isSwimming{
    }
  }

  isVarsIntEqual{
    lhs:t="tryBuild"
    rhs_value:i=0
  }

  periodicTimer{
    timeParam:t="onCheckBuildTimer"
    timePeriod:p2=3.0, 7.0
  }

  ignoreChance{
    chance:r=0.1
  }

  orderedSelector{

    sequencer{

      isEngineer{
      }

      orderedSelector{

        sequencer{

          checkBuildCustomRespawnPoint{
            buildPosParam:t="buildPos"
          }

          setIntVar{
            to:t="tryBuild"
            value:i=1
          }

          setIntVar{
            to:t="buildWhat"
            value:i=1
          }

          initPeriodicTimer{
            timeParam:t="onForceBuildTimer"
            timePeriod:p2=5.0, 7.0
          }

          recalculateTree{
          }
        }

        sequencer{

          checkBuildAmmoBox{
            buildPosParam:t="buildPos"
          }

          setIntVar{
            to:t="tryBuild"
            value:i=1
          }

          setIntVar{
            to:t="buildWhat"
            value:i=2
          }

          initPeriodicTimer{
            timeParam:t="onForceBuildTimer"
            timePeriod:p2=5.0, 7.0
          }

          recalculateTree{
          }
        }
      }
    }

    sequencer{

      findWeaponSlotWithTag{
        tag:t="medBox"
        toParam:t="buildToolSlot"
      }

      orderedSelector{

        sequencer{

          checkPlaceMedBox{
            buildPosParam:t="buildPos"
          }

          setIntVar{
            to:t="tryBuild"
            value:i=1
          }

          setIntVar{
            to:t="buildWhat"
            value:i=3
          }

          initPeriodicTimer{
            timeParam:t="onForceBuildTimer"
            timePeriod:p2=5.0, 7.0
          }

          recalculateTree{
          }
        }
      }
    }
  }
}

sequencer{
  name:t="sub.tryBuildAndPlace"

  checkAtTime{
    timeParam:t="enemyNearTime"
    range:p2=5.0, 1000000.0
  }

  not{

    isSwimming{
    }
  }

  exitHandler{

    sequencer{

      reaction{
        event:t="onBulletNearby"

        sequencer{

          periodicTimer{
            timeParam:t="onForceBuildTimer"
            timePeriod:p2=3.0, 5.0
          }

          recalculateTree{
          }
        }
      }

      reaction{
        event:t="onTraceableDanger"

        continue{
        }
      }

      reaction{
        event:t="onEnemyPlayerNear"

        sequencer{

          periodicTimer{
            timeParam:t="onForceBuildTimer"
            timePeriod:p2=3.0, 5.0
          }

          findDanger{
            paramName:t="shootEnemy"
            radiusParamName:t="enemyNearRadius"
            minDanger:r=0.1
            tag:t="human"
          }

          recalculateTree{
          }
        }
      }

      reaction{
        event:t="regularCheck"

        repeat{
          count:i=1

          subTree{
            name:t=""
            treeName:t="sub.checkDowned"
          }

          subTree{
            name:t=""
            treeName:t="sub.checkBurning"
          }

          subTree{
            name:t=""
            treeName:t="sub.swimUpCheck"
          }

          subTree{
            name:t=""
            treeName:t="sub.tryToOpenDoors"
          }

          subTree{
            name:t=""
            treeName:t="sub.findDangerGrenadeNearby"
          }
        }
      }

      setCurrentAiAction{
        state:t="move"
      }

      orderedSelector{

        sequencer{

          isVarsIntEqual{
            lhs:t="buildWhat"
            rhs_value:i=1
          }

          isEngineer{
          }

          findWeaponSlotWithTag{
            tag:t="buildingTool"
            toParam:t="buildToolSlot"
          }

          moveToPos{
            posParam:t="buildPos"
            sprintTimerRange:p2=10.0, 20.0
            minDistToSprint:r=4.0
            distThreshold:r=5.0
            avoidAiObstacles:b=no
            timeToStuck:r=5.0
          }

          moveToPos{
            posParam:t="buildPos"
            sprintTimerRange:p2=10.0, 20.0
            minDistToSprint:r=4.0
            distThreshold:r=1.5
            avoidAiObstacles:b=no
            timeToStuck:r=5.0
          }

          changeWeapon{
            param:t="buildToolSlot"
          }

          wait{
            range:p2=0.5, 1.0
            resetable:b=yes
          }

          startBuildCustomRespawnPoint{
            buildPosParam:t="buildPos"
            buildTargetEidParam:t="buildTarget"
            waitStartBuildMaxTime:r=2.0
          }

          subTree{
            name:t=""
            treeName:t="sub.finishBuildTarget"
          }
        }

        sequencer{

          isVarsIntEqual{
            lhs:t="buildWhat"
            rhs_value:i=2
          }

          isEngineer{
          }

          findWeaponSlotWithTag{
            tag:t="buildingTool"
            toParam:t="buildToolSlot"
          }

          changeWeapon{
            param:t="buildToolSlot"
          }

          wait{
            range:p2=0.5, 1.5
            resetable:b=yes
          }

          moveToPos{
            posParam:t="buildPos"
            sprintTimerRange:p2=10.0, 20.0
            minDistToSprint:r=4.0
            distThreshold:r=1.1
            avoidAiObstacles:b=no
            timeToStuck:r=5.0
          }

          startBuildAmmoBox{
            buildPosParam:t="buildPos"
            buildTargetEidParam:t="buildTarget"
            waitStartBuildMaxTime:r=2.0
          }

          subTree{
            name:t=""
            treeName:t="sub.finishBuildTarget"
          }
        }

        sequencer{

          isVarsIntEqual{
            lhs:t="buildWhat"
            rhs_value:i=3
          }

          findWeaponSlotWithTag{
            tag:t="medBox"
            toParam:t="buildToolSlot"
          }

          changeWeapon{
            param:t="buildToolSlot"
          }

          wait{
            range:p2=0.5, 1.5
            resetable:b=yes
          }

          moveToPos{
            posParam:t="buildPos"
            sprintTimerRange:p2=10.0, 20.0
            minDistToSprint:r=4.0
            distThreshold:r=1.1
            avoidAiObstacles:b=no
            timeToStuck:r=5.0
          }

          placeMedBox{
            buildPosParam:t="buildPos"
          }
        }
      }

      wait{
        range:p2=0.5, 1.5
        resetable:b=yes
      }

      wait{
        range:p2=1.0, 2.0
        resetable:b=yes
      }

      chooseBestWeapon{
        targetParam:t="shootEnemy"
      }
    }

    chooseBestWeapon{
      targetParam:t="shootEnemy"
    }
  }
}

sequencer{
  name:t="sub.checkHealTeammatesAround"

  not{

    isSwimming{
    }
  }

  checkAtTime{
    timeParam:t="enemyNearTime"
    range:p2=5.0, 1000000.0
  }

  periodicTimer{
    timeParam:t="onCheckHealMatesTimer"
    timePeriod:p2=2.0, 3.0
  }

  checkHealTeammatesAround{
    healMateEidParam:t="healMateEid"
    checkAroundDistance:r=20.0
  }

  setIntVar{
    to:t="tryHealMate"
    value:i=1
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.checkHealSquadmatesAround"

  not{

    isSwimming{
    }
  }

  checkAtTime{
    timeParam:t="enemyNearTime"
    range:p2=5.0, 1000000.0
  }

  periodicTimer{
    timeParam:t="onCheckHealMatesTimer"
    timePeriod:p2=2.0, 3.0
  }

  checkHealTeammatesAround{
    healMateEidParam:t="healMateEid"
    checkAroundDistance:r=20.0
    selfSquadOnly:b=yes
  }

  setIntVar{
    to:t="tryHealMate"
    value:i=1
  }

  recalculateTree{
  }
}

sequencer{
  name:t="sub.tryHealTeammateAround"

  not{

    isSwimming{
    }
  }

  isVarsIntEqual{
    lhs:t="tryHealMate"
    rhs_value:i=1
  }

  setIntVar{
    to:t="tryHealMate"
    value:i=0
  }

  checkTarget{
    targetUnitParam:t="healMateEid"
  }

  copyIntVar{
    to:t="healRequester"
    from:t="healMateEid"
  }

  subTree{
    name:t=""
    treeName:t="sub.healReq"
  }
}

sequencer{
  name:t="sub.moveToRegroupPosition"

  getRegroupPos{
    posParam:t="regroupPosition"
  }

  getOrderPosition{
    posParam:t="regroupPosition"
    orderPosParam:t="wishPosition"
  }

  subTree{
    name:t=""
    treeName:t="sub.moveToPosition"
  }
}

sequencer{
  name:t="sub.moveToPosition"

  wait{
    range:p2=0.1, 0.3
    resetable:b=yes
  }

  getAgentAIPos{
    outPosParam:t="moveFromPos"
  }

  orderedSelector{

    sequencer{

      orderedSelector{

        isOnNavmesh{
        }

        subTree{
          name:t=""
          treeName:t="sub.returnToNavmesh"
        }
      }

      orderedSelector{

        moveToPos{
          posParam:t="wishPosition"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=1.5
          lookVisc:r=0.1
          tryClimbing:b=yes
          maxStanceParam:t="maxStance"
          stuckDirParam:t="stuckDir"
          timeToStuck:r=0.9
          incObstacles:b=yes
          avoidAiObstacles:b=no
          distThreshold:r=1.0
        }

        moveToPos{
          posParam:t="wishPosition"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=1.5
          lookVisc:r=0.1
          tryClimbing:b=yes
          maxStanceParam:t="maxStance"
          stuckDirParam:t="stuckDir"
          timeToStuck:r=0.9
          incObstacles:b=no
          avoidAiObstacles:b=no
          distThreshold:r=0.1
        }
      }

      setIntVar{
        to:t="resetAIPointsGenerator"
        value:i=1
      }
    }

    sequencer{

      success{

        sequencer{

          isUnderwater{
          }

          findSwimUpPos{
            posParam:t="swimUpPos"
            swimUpDirParam:t="swimUpDir"
            radius:r=1.0
            tries:i=5
          }

          parallel{

            moveToPos{
              posParam:t="swimUpPos"
              sprintTimerRange:p2=10.0, 20.0
              minDistToSprint:r=10.0
              distThreshold:r=1.5
              avoidAiObstacles:b=yes
            }

            waitSwimUpPos{
              delay:r=0.1
              maxTime:r=4.0
              swimUpDirParam:t="swimUpDir"
            }
          }

          swimUp{
            swimUpDirParam:t="swimUpDir"
          }
        }
      }

      orderedSelector{

        moveToPos{
          posParam:t="wishPosition"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=1.5
          lookVisc:r=0.1
          tryClimbing:b=yes
          maxStanceParam:t="maxStance"
          stuckDirParam:t="stuckDir"
          timeToStuck:r=2.5
          incObstacles:b=yes
          avoidAiObstacles:b=no
          distThreshold:r=1.0
        }

        moveToPos{
          posParam:t="wishPosition"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=1.5
          lookVisc:r=0.1
          tryClimbing:b=yes
          maxStanceParam:t="maxStance"
          stuckDirParam:t="stuckDir"
          timeToStuck:r=2.5
          incObstacles:b=no
          avoidAiObstacles:b=no
          distThreshold:r=0.1
        }
      }

      setIntVar{
        to:t="resetAIPointsGenerator"
        value:i=1
      }
    }

    sequencer{

      or{

        isSwimming{
        }

        isUnderwater{
        }
      }

      not{

        checkDistance{
          posParam:t="wishPosition"
          radius:r=2.0
          yRadius:r=1.0
        }
      }

      orderedSelector{

        moveByDir{
          endPos:t="wishPosition"
          duration:r=1.2
          distThresholsd:r=0.2
        }

        sequencer{

          findWayBackToNavmesh{
            outPosParam:t="outStuckPos"
          }

          moveByDir{
            endPos:t="outStuckPos"
            duration:r=1.2
            distThresholsd:r=0.2
          }
        }
      }

      setIntVar{
        to:t="resetAIPointsGenerator"
        value:i=1
      }
    }

    isUnderwater{
    }

    ifThenElse{

      and{

        isOnNavmesh{
        }

        not{

          isVarsIntEqual{
            lhs:t="resetAIPointsGenerator"
            rhs_value:i=2
          }
        }
      }

      failed{

        subTree{
          name:t=""
          treeName:t="sub.moveToUnstuck"
        }
      }

      failed{

        subTree{
          name:t=""
          treeName:t="sub.returnToNavmesh"
        }
      }
    }
  }
}

sequencer{
  name:t="sub.returnToNavmesh"

  wait{
    range:p2=0.1, 0.2
    resetable:b=yes
  }

  orderedSelector{

    sequencer{

      findWayBackToNavmesh{
        outPosParam:t="outStuckPos"
      }

      moveByDir{
        endPos:t="outStuckPos"
        duration:r=1.2
        distThresholsd:r=0.1
      }

      setIntVar{
        to:t="resetAIPointsGenerator"
        value:i=1
      }
    }

    setIntVar{
      to:t="resetAIPointsGenerator"
      value:i=1
    }
  }
}

sequencer{
  name:t="sub.moveToUnstuck"

  wait{
    range:p2=0.1, 0.2
    resetable:b=yes
  }

  orderedSelector{

    sequencer{

      getPointAroundAIPos{
        dirParam:t="stuckDir"
        outPosParam:t="outStuckPos"
        forwPosParam:t="outStuckForwPos"
        fromPosParam:t="moveFromPos"
        toPosParam:t="wishPosition"
        resetAIPointsGeneratorParam:t="resetAIPointsGenerator"
      }

      moveByDir{
        endPos:t="outStuckPos"
        duration:r=1.5
        distThresholsd:r=0.1
      }
    }

    setIntVar{
      to:t="resetAIPointsGenerator"
      value:i=2
    }
  }
}

sequencer{
  name:t="sub.stayInCover"

  isInCover{
  }

  setCurrentAiAction{
    state:t="in_cover"
  }

  getCoverPosition{
    coverPosParam:t="coverPos"
  }

  chooseMaxStance{
  }

  orderedSelector{

    sequencer{

      findDanger{
        paramName:t="testEnemy"
        radiusParamName:t="enemyRadius"
        minDanger:r=-1.0
        tag:t="human"
      }

      selectStanceInCover{
        minStanceParam:t="minStance"
        maxStanceParam:t="maxStance"
        stanceParam:t="coverStance"
        safe:b=yes
      }

      changeStance{
        stanceName:t="stand"
        maxStanceParam:t="coverStance"
      }
    }

    sequencer{

      chooseRandomStance{
        stanceParam:t="standStance"
        minStance:i=1
        maxStance:i=2
      }

      changeStance{
        stanceName:t="stand"
        maxStanceParam:t="standStance"
      }
    }
  }

  orderedSelector{

    findPotentialEnemyPos{
      posParam:t="potentialEnemyPos"
      minNoiseLevel:r=3.0
    }

    sequencer{

      periodicTimer{
        timeParam:t="standInCoverFindDangerAttrationPosTimer"
        timePeriod:p2=4.0, 6.0
      }

      findDangerAttractionPos{
        posParam:t="potentialEnemyPos"
        radius:r=0.0
        minNoiseLevel:r=3.0
      }
    }

    continue{
    }
  }

  orderedSelector{

    sequencer{

      ignoreChance{
        chance:r=0.1
      }

      checkAtTime{
        timeParam:t="rememberEnemyTime"
        range:p2=0.0, 25.0
      }

      checkTarget{
        targetUnitParam:t="rememberEnemy"
      }

      copyPoint3Var{
        to:t="potentialEnemyPos"
        from:t="rememberEnemyPos"
      }

      parallel{

        wait{
          range:p2=5.0, 10.0
          resetable:b=yes
        }

        wanderLook{
          posParam:t="rememberEnemyPos"
          range:p2=0.2, 0.1
          maxStanceParam:t="coverStance"
        }
      }
    }

    sequencer{

      findPotentialEnemyDirectionEntryPoint{
        posParam:t="potentialEnemyPos"
      }

      parallel{

        wait{
          range:p2=5.0, 15.0
          resetable:b=yes
        }

        wanderLook{
          posParam:t="potentialEnemyPos"
          range:p2=0.2, 0.1
          maxStanceParam:t="coverStance"
        }
      }
    }
  }
}

sequencer{
  name:t="sub.stayAtPos"

  setCurrentAiAction{
    state:t="stand"
  }

  parallel{

    validateStandPosition{
    }

    wanderLook{
      posParam:t="potentialEnemyPos"
      range:p2=0.2, 0.1
      maxStanceParam:t="maxStance"
    }
  }

  parallel{

    validateStandPosition{
    }

    wanderLook{
      posParam:t="potentialEnemyPos"
      range:p2=0.2, 0.1
      maxStanceParam:t="maxStance"
    }
  }

  parallel{

    wait{
      range:p2=1.5, 2.0
      resetable:b=yes
    }

    wanderLook{
      posParam:t="potentialEnemyPos"
      range:p2=0.2, 0.1
      maxStanceParam:t="maxStance"
    }
  }

  orderedSelector{

    findPotentialEnemyPos{
      posParam:t="potentialEnemyPos"
      minNoiseLevel:r=3.0
    }

    sequencer{

      periodicTimer{
        timeParam:t="standFindDangerAttrationPosTimer"
        timePeriod:p2=4.0, 6.0
      }

      findDangerAttractionPos{
        posParam:t="potentialEnemyPos"
        radius:r=0.0
        minNoiseLevel:r=3.0
      }
    }

    continue{
    }
  }

  orderedSelector{

    sequencer{

      ignoreChance{
        chance:r=0.5
      }

      chooseRandomStance{
        stanceParam:t="standStance"
        minStance:i=1
        maxStance:i=2
      }

      changeStance{
        stanceName:t="stand"
        maxStanceParam:t="standStance"
      }
    }

    sequencer{

      ignoreChance{
        chance:r=0.95
      }

      chooseRandomStance{
        stanceParam:t="standStance"
        minStance:i=0
        maxStance:i=1
      }

      changeStance{
        stanceName:t="stand"
        maxStanceParam:t="standStance"
      }
    }

    continue{
    }
  }

  orderedSelector{

    sequencer{

      ignoreChance{
        chance:r=0.2
      }

      checkAtTime{
        timeParam:t="rememberEnemyTime"
        range:p2=0.0, 20.0
      }

      checkTarget{
        targetUnitParam:t="rememberEnemy"
      }

      copyPoint3Var{
        to:t="potentialEnemyPos"
        from:t="rememberEnemyPos"
      }

      parallel{

        wait{
          range:p2=5.0, 10.0
          resetable:b=yes
        }

        wanderLook{
          posParam:t="rememberEnemyPos"
          range:p2=0.2, 0.1
          maxStanceParam:t="coverStance"
        }
      }
    }

    parallel{

      wait{
        range:p2=5.0, 15.0
        resetable:b=yes
      }

      wanderLook{
        posParam:t="potentialEnemyPos"
        range:p2=0.2, 0.1
        maxStanceParam:t="maxStance"
      }
    }
  }

  findPotentialEnemyDirectionEntryPoint{
    posParam:t="potentialEnemyPos"
  }

  sequencer{

    ignoreChance{
      chance:r=0.5
    }

    chooseRandomStance{
      stanceParam:t="standStance"
      minStance:i=1
      maxStance:i=2
    }

    changeStance{
      stanceName:t="stand"
      maxStanceParam:t="standStance"
    }
  }
}

sequencer{
  name:t="sub.moveToCover"

  subTree{
    name:t=""
    treeName:t="sub.tryToSaveOrFindCover"
  }

  subTree{
    name:t=""
    treeName:t="sub.moveToPosition"
  }
}

sequencer{
  name:t="sub.defendPointMoveToPosition"

  setIntVar{
    to:t="isOnDefendPoint"
    value:i=0
  }

  setIntVar{
    to:t="isOnDefendPoint"
    value:i=1
  }

  subTree{
    treeName:t="sub.moveToRegroupPosition"
  }
}

sequencer{
  name:t="sub.updateRegroupPosDefault"

  isLeader{
  }

  success{

    setSquadFormation{
      formation:t="standard"
    }
  }

  orderedSelector{

    sequencer{

      findDanger{
        paramName:t="testEnemy"
        radiusParamName:t="enemyNearRadius"
        minDanger:r=-1.0
        tag:t="human"
      }

      periodicTimer{
        timeParam:t="onChangeLeaderFollowPos"
        timePeriod:p2=10.0, 12.5
      }
    }

    periodicTimer{
      timeParam:t="onChangeLeaderFollowPos"
      timePeriod:p2=30.0, 40.0
    }
  }

  orderedSelector{

    sequencer{

      findPointInCapzone{
        posParam:t="regroupPosition"
      }

      resetNearCapzone{
      }
    }

    findPointNearCapzone{
      posParam:t="regroupPosition"
    }
  }
}

sequencer{
  name:t="sub.updateRegroupPosTrain"

  isLeader{
  }

  getPointInTrainCapzone{
    posParam:t="regroupPosition"
  }
}

sequencer{
  name:t="sub.popFromCoverAttackCover"

  getTime{
    to:t="fastReactTime"
  }

  getCoverPosAndDir{
    coverIndexParam:t="coverAttackCover"
    coverSlotParam:t="coverAttackCoverSlot"
  }

  rotateToPoint{
    posParam:t="coverLookPos"
  }

  setIntVar{
    to:t="coverAttack"
    value:i=2
  }

  chooseMinMaxStancesForCoverAttack{
  }

  changeStanceForCoverAttack{
    hide:b=no
  }

  orderedSelector{

    sequencer{

      isVarsIntEqual{
        lhs:t="coverAttackType"
        rhs_value:i=4
      }

      getCoverPosAndDir{
        coverIndexParam:t="coverAttackCover"
        coverSlotParam:t="coverAttackCoverSlot"
        outLeftPosParam:t="coverWalkPos"
      }

      moveByDir{
        endPos:t="coverWalkPos"
        duration:r=2.5
        distThresholsd:r=0.3
      }

      rotateToPoint{
        posParam:t="coverLookPos"
      }
    }

    sequencer{

      isVarsIntEqual{
        lhs:t="coverAttackType"
        rhs_value:i=5
      }

      getCoverPosAndDir{
        coverIndexParam:t="coverAttackCover"
        coverSlotParam:t="coverAttackCoverSlot"
        outRightPosParam:t="coverWalkPos"
      }

      moveByDir{
        endPos:t="coverWalkPos"
        duration:r=2.5
        distThresholsd:r=0.3
      }

      rotateToPoint{
        posParam:t="coverLookPos"
      }
    }

    continue{
    }
  }

  wait{
    range:p2=0.1, 0.2
    resetable:b=yes
  }
}

sequencer{
  name:t="sub.hideToCoverAttackCover"

  setIntVar{
    to:t="minStance"
    value:i=2
  }

  setIntVar{
    to:t="maxStance"
    value:i=2
  }

  setIntVar{
    to:t="coverAttack"
    value:i=1
  }

  getTime{
    to:t="fastReactTime"
  }

  changeStance{
    stanceName:t="stand"
    maxStanceParam:t="maxStance"
  }

  orderedSelector{

    moveToPos{
      posParam:t="coverPos"
      sprintTimerRange:p2=10.0, 20.0
      minDistToSprint:r=0.0
      distThreshold:r=0.3
      avoidAiObstacles:b=no
      timeToStuck:r=0.3
    }

    moveByDir{
      endPos:t="coverPos"
      duration:r=1.5
      distThreshold:r=0.3
    }
  }

  rotateToPoint{
    posParam:t="coverLookPos"
  }

  chooseMinMaxStancesForCoverAttack{
  }

  changeStanceForCoverAttack{
    hide:b=yes
  }

  wait{
    range:p2=0.5, 0.7
    resetable:b=yes
  }

  wait{
    range:p2=0.1, 0.2
    resetable:b=yes
  }

  decreaseDangerLevel{
    paramName:t="dangerLevel"
    decreaseCoef:r=0.1
  }
}

sequencer{
  name:t="sub.retreatFromCoverAttackCover"
}

orderedSelector{
  name:t="sub.tryToOpenDoors"

  findObstaclesAlongsidePath{
  }
}

orderedSelector{
  name:t="sub.tryToSaveOrFindCover"

  subTree{
    name:t=""
    refId:t="checkCoverRef"
  }

  subTree{
    name:t=""
    refId:t="findCoverRef"
  }
}

orderedSelector{
  name:t="sub.checkEndCoverAttack"

  isVarsIntEqual{
    lhs:t="coverAttack"
    rhs_value:i=0
  }

  sequencer{

    checkCoverForCoverAttack{
    }

    checkAtTime{
      timeParam:t="coverAttackEnemyTime"
      range:p2=0.0, 5.0
    }

    success{

      sequencer{

        checkTargetTraceable{
          targetParam:t="coverAttackEnemy"
        }

        getTime{
          to:t="coverAttackEnemyTime"
        }
      }
    }
  }

  sequencer{

    success{

      ignoreCover{
        coverIndexParam:t="coverAttackCover"
        coverSlotParam:t="coverAttackCoverSlot"
        timeIgnore:p2=8.0, 16.0
      }
    }

    setIntVar{
      to:t="coverAttack"
      value:i=0
    }

    setIntVar{
      to:t="coverAttackType"
      value:i=0
    }

    setIntVar{
      to:t="coverAttackCover"
      value:i=-1
    }

    setIntVar{
      to:t="coverAttackCoverSlot"
      value:i=0
    }

    setIntVar{
      to:t="coverAttackEnemy"
      value:i=0
    }

    setRealVar{
      to:t="coverAttackEnemyTime"
      value:r=0.0
    }

    wait{
      range:p2=0.1, 0.2
      resetable:b=yes
    }
  }
}

orderedSelector{
  name:t="sub.tryBeginCoverAttack"

  not{

    isVarsIntEqual{
      lhs:t="coverAttack"
      rhs_value:i=0
    }
  }

  not{

    sequencer{

      reaction{
        event:t="regularCheck"

        findObstaclesAlongsidePath{
        }
      }

      reaction{
        event:t="onEnemyPlayerNear"

        orderedSelector{

          sequencer{

            findDanger{
              paramName:t="meleeEnemy"
              radiusParamName:t="enemyMeleeRadius"
              minDanger:r=0.5
              tag:t="human"
            }

            decreaseDangerLevel{
              paramName:t="dangerLevel"
              decreaseCoef:r=0.1
            }

            setIntVar{
              to:t="coverAttack"
              value:i=0
            }

            recalculateTree{
            }
          }

          sequencer{

            findDanger{
              paramName:t="reactShootEnemy"
              radiusParamName:t="enemyNearRadius"
              minDanger:r=0.5
              tag:t="human"
            }

            orderedSelector{

              isVarsIntEqual{
                lhs:t="reactShootEnemy"
                rhs:t="shootEnemy"
              }

              sequencer{

                decreaseDangerLevel{
                  paramName:t="dangerLevel"
                  decreaseCoef:r=0.1
                }

                setIntVar{
                  to:t="coverAttack"
                  value:i=0
                }

                recalculateTree{
                }
              }
            }
          }
        }
      }

      reaction{
        event:t="onTraceableDanger"

        continue{
        }
      }

      reaction{
        event:t="onBulletNearby"

        continue{
        }
      }

      getRegroupPos{
        posParam:t="regroupPosition"
      }

      findCoverForCoverAttack{
        targetParam:t="shootEnemy"
        approachPosParam:t="regroupPosition"
      }

      wait{
        range:p2=0.1, 0.2
        resetable:b=yes
      }

      wait{
        range:p2=0.1, 0.2
        resetable:b=yes
      }

      getCoverPosAndDir{
        coverIndexParam:t="coverAttackCover"
        coverSlotParam:t="coverAttackCoverSlot"
        outPosParam:t="coverPos"
      }

      setIntVar{
        to:t="minStance"
        value:i=2
      }

      setIntVar{
        to:t="maxStance"
        value:i=2
      }

      setIntVar{
        to:t="coverAttack"
        value:i=1
      }

      setIntVar{
        to:t="dangerNearbyBeware"
        value:i=1
      }

      changeStance{
        stanceName:t="stand"
        maxStanceParam:t="maxStance"
      }

      orderedSelector{

        moveToPos{
          posParam:t="coverPos"
          sprintTimerRange:p2=10.0, 20.0
          minDistToSprint:r=0.0
          distThreshold:r=0.3
          avoidAiObstacles:b=no
          timeToStuck:r=0.3
        }

        continue{
        }
      }

      setPosFromEntity{
        to:t="coverLookPos"
        from:t="shootEnemy"
      }

      rotateToPoint{
        posParam:t="coverLookPos"
      }

      copyIntVar{
        to:t="coverAttackEnemy"
        from:t="shootEnemy"
      }

      getTime{
        to:t="coverAttackEnemyTime"
      }

      chooseMinMaxStancesForCoverAttack{
      }

      changeStanceForCoverAttack{
        hide:b=yes
      }

      decreaseDangerLevel{
        paramName:t="dangerLevel"
        decreaseCoef:r=0.1
      }
    }
  }

  isVarsRealLess{
    lhs:t="dangerLevel"
    rhs_value:r=0.9
  }
}

orderedSelector{
  name:t="sub.performCoverAttackMoves"

  sequencer{

    isVarsIntEqual{
      lhs:t="coverAttack"
      rhs_value:i=1
    }

    wait{
      range:p2=0.3, 0.5
      resetable:b=yes
    }

    orderedSelector{

      sequencer{

        reaction{
          event:t="regularCheck"

          findObstaclesAlongsidePath{
          }
        }

        reaction{
          event:t="onEnemyPlayerNear"

          continue{
          }
        }

        reaction{
          event:t="onTraceableDanger"

          continue{
          }
        }

        reaction{
          event:t="onBulletNearby"

          continue{
          }
        }

        getCoverPosAndDir{
          coverIndexParam:t="coverAttackCover"
          coverSlotParam:t="coverAttackCoverSlot"
          outPosParam:t="coverPos"
        }

        orderedSelector{

          checkDistance{
            posParam:t="coverPos"
            radius:r=1.0
            yRadius:r=1.0
          }

          subTree{
            treeName:t="sub.hideToCoverAttackCover"
          }
        }

        orderedSelector{

          ignoreChance{
            chance:r=0.3
          }

          wait{
            range:p2=0.1, 0.5
            resetable:b=yes
          }
        }

        orderedSelector{

          checkTargetTraceable{
            targetParam:t="coverAttackEnemy"
          }

          ignoreChance{
            chance:r=0.5
          }

          failed{

            sequencer{

              increaseDangerLevel{
                paramName:t="dangerLevel"
                targetParam:t="coverAttackEnemy"
              }

              increaseDangerLevel{
                paramName:t="dangerLevel"
                targetParam:t="coverAttackEnemy"
              }
            }
          }
        }

        checkReloadWeapon{
        }

        wait{
          range:p2=0.3, 0.5
          resetable:b=yes
        }

        subTree{
          treeName:t="sub.popFromCoverAttackCover"
        }

        ifThenElse{

          checkTooManyEnemiesWatching{
          }

          sequencer{

            increaseDangerLevel{
              paramName:t="dangerLevel"
              targetParam:t="coverAttackEnemy"
            }

            subTree{
              treeName:t="sub.hideToCoverAttackCover"
            }

            wait{
              range:p2=0.5, 1.0
              resetable:b=yes
            }

            break{
            }
          }

          continue{
          }
        }

        checkTarget{
          targetUnitParam:t="coverAttackEnemy"
        }

        setPosFromEntity{
          to:t="coverLookPos"
          from:t="coverAttackEnemy"
        }

        setIntVar{
          to:t="coverAttack"
          value:i=2
        }

        setIntVar{
          to:t="dangerNearbyBeware"
          value:i=1
        }

        getTime{
          to:t="coverAttackEnemyTime"
        }
      }

      sequencer{

        ignoreCover{
          coverIndexParam:t="coverAttackCover"
          coverSlotParam:t="coverAttackCoverSlot"
          timeIgnore:p2=8.0, 16.0
        }

        decreaseDangerLevel{
          paramName:t="dangerLevel"
          decreaseCoef:r=0.1
        }

        setIntVar{
          to:t="dangerNearbyBeware"
          value:i=1
        }

        setIntVar{
          to:t="coverAttack"
          value:i=0
        }
      }
    }
  }

  sequencer{

    isVarsIntEqual{
      lhs:t="coverAttack"
      rhs_value:i=2
    }

    orderedSelector{

      checkTarget{
        targetUnitParam:t="coverAttackEnemy"
      }

      not{

        sequencer{

          not{

            ignoreChance{
              chance:r=0.1
            }
          }

          ignoreCover{
            coverIndexParam:t="coverAttackCover"
            coverSlotParam:t="coverAttackCoverSlot"
            timeIgnore:p2=8.0, 16.0
          }
        }
      }

      failed{

        sequencer{

          setIntVar{
            to:t="coverAttack"
            value:i=0
          }

          decreaseDangerLevel{
            paramName:t="dangerLevel"
            decreaseCoef:r=0.1
          }
        }
      }
    }

    orderedSelector{

      not{

        orderedSelector{

          checkReloadWeapon{
            checkOnly:b=yes
          }

          not{

            isVarsRealLess{
              lhs:t="dangerLevel"
              rhs_value:r=0.9
            }
          }
        }
      }

      sequencer{

        subTree{
          treeName:t="sub.hideToCoverAttackCover"
        }

        wait{
          range:p2=0.1, 0.2
          resetable:b=yes
        }

        break{
        }
      }
    }

    getTime{
      to:t="coverAttackEnemyTime"
    }

    setIntVar{
      to:t="dangerNearbyBeware"
      value:i=1
    }
  }

  continue{
  }
}

repeatUntilFail{
  name:t="sub.finishBuildTarget"
  count:i=1

  checkTarget{
    targetUnitParam:t="buildTarget"
    ignoreDead:b=no
  }

  findPointNearTarget{
    posParam:t="buildPosition"
    dist:p2=2.0, 2.5
    targetParam:t="buildTarget"
    traceTarget:b=no
    reusePrevPos:b=no
  }

  moveToPos{
    posParam:t="buildPosition"
    sprintTimerRange:p2=10.0, 20.0
    minDistToSprint:r=4.0
    distThreshold:r=0.5
    avoidAiObstacles:b=no
  }

  changeStance{
    stanceName:t="crouch"
    maxStanceParam:t="maxStance"
  }

  parallel{

    lookAtTarget{
      targetUnitParam:t="buildTarget"
      rotateBody:b=yes
      allowDead:b=yes
    }

    interactWithBuildingTarget{
      targetUnitParam:t="buildTarget"
    }
  }
}